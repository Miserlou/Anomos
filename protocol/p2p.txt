P2P Deets.

(n%) after each item is rough idea of how close to being implemented the part is.

Startup
-------
Client's SingleportListener creates a passive socket on open port. Connections
to this peer will come in through this passive socket (aka: server socket).

Initial Connection
------------------
-Client connects to Tracker for first time. (90%)
    -Tracker responds with dictionary of NeighborIDs each mapped onto a tuple of
     (IP address, port, [peer_id? BT does this, should we?]) (90%)
     I think for the peer_id here should be replaced by the neighbor ID. On
     the client side peer_id is only used to ensure that we don't already have a
     connection to that peer.

-Client makes initial connections to neighbors:
 (Unstarred means "This is how it currently works", Starred is proposed implementation for Anomos)
    1) Rerequest reads the actual tracker response, 
        -Calls encoder.start_connection((IP, Port), NeighborID)   
    2) Encoder checks that it's not already connected to that peer, and that we're
       accepting new connections.
        -Calls raw_server.start_connection((IP,Port), None, context)
            Raw_server creates the actual socket and returns a Single_Socket object
        -Encoder creates the Connection object for reading/writing to that Single_Socket
    3) On the receiving end, the peer's server_socket picks up the request and opens
       a new Single_Socket. It then calls SingleportListener.external_connection_made
       which initializes the connection object which will respond to data on this socket.
    4) The sending peer's Connection object writes:
        len(protocol_name) + protocol_name + (chr(0) * 8) + infohash
    4*) The sending peer's Connection object should write:
        len(protocol_name) + protocol_name + (chr(0) * 8) + NeighborID
        (!) We can't send the NeighborID plaintext. That means that either the 
            NeighborID is encrypted from the tracker or we need our Neighbor's 
            public key.
    5) The receiving peer's Connection object reads this and (if all goes well) assigns it's
        self.encoder variable to the local Encoder object for the torrent.
    5*) The receiving peer reads the data, checks that the NeighborID is not already in use.
        No change in its encoder variable.
    6) The receiving peer's Connection then writes:
        len(protocol_name)) + protocol_name + (chr(0) * 8) + infohash + my_id
    6*) If nothing is wrong the receiving peer's Connection writes:
        len(protocol_name)) + protocol_name + (chr(0) * 8) + NeighborID
        (!) See 4*. Do we bother resending this? We need to send some kind of
            confirmation, even if it's not the NeighborID.
            Having our Neighbors public key might come in handy in many situations.
            Let's consider it.
        If something went wrong they would write:
        len(protocol_name)) + protocol_name + (chr(0) * 8) + NeighborDisconnect
    7) The sending peer reads this and confirms that the infohash it sent matches the one
     it received. It also checks that the ID received does not match its own and that it
     is not already connected to this peer for this torrent.
    7*) The sending peer reads this, confirms that the received NeighborID matches the one
        it sent, and adds the peer to it's neighbors dictionary in SingleportListener
        format: { NeighborID: (IP, Port)}
    *** The Anomos handshake is over, the following is how it continues in BT ***
    8) The sending peer replies with their own ID, and the receiving peer performs the same
     checks on that.
    9) The handshake has completed and now both peers create their upload/download objects
    10) Requests/Pieces/Chokes/Unchokes -- Everything happens here.

Requesting a file
-----------------
-Client connects to Tracker, specifying an infohash. (90%)
    Tracker responds with a TC dictionary, a set of 1024 byte tracking codes to 
    initialize connections with. (90%)
    Since the tracker connection is already encrypted, the first digit of the tracking
    code is not encrypted, instead, it's the value each TC in the dictionary is
    mapped to. This way the client only has to decrypt the TC-dict, and not
    each tracking code individually. (0% -- but trivial.)

-Client receives and decrypts tracker response (100%)

-Client sends each TC to the neighbor specified by TC-dict
    Here we have to look up the neighbor's IP and Port in SingleportListener
    and call RawServer.start_connection for each of those pairs. 

Sending/Receiving a TC (10%)
--------------
    0) A socket is opened between the two peers.
    1) Sending peer writes:
        len(protocol_name) + protocol_name + (chr(0) * 8) + Request to open circuit
    2) This is our chance to do things like, not allow the connection (if we're overloaded)
       Receiving peer checks that the sending peer is one of their neighbors and decides to
       accept/deny the connection. (always denying non-neighbor connections)
       Receiving peer writes:
        len(protocol_name) + protocol_name + (chr(0) * 8) + Accept/Deny
    3) Accept: Sending peer writes Tracking Code 
       Deny: Backpropagate deny messages to source.
            (!) The source should relay this to the tracker, which should stop issuing TCs
                to anyone in the path. Unblocking them only after their next announce.
                In each peer's next announce they should also note that they received the Deny.
    4) Receiving peer reads/decrypts the Tracking Code, and stores the decrypted data. 
    5) Receiving peer is the target of the TC: Get response TC
       Decrypted data is garbage: Backpropagate failure message.
       More relaying to be done: Goto 6.
    6) Receiving peer initializes a Relayer object for the transfer. Ownership of the
       incoming socket is transferred to this Relayer. And the relayer initializes the
       new connection as per the TC-Num.

Relaying (1%)
--------
    New data comes in on insocket, Relayer directs it to outsocket.
    (!) Here's where all the exciting things like mixing can happen.

    Data d comes in on an open socket
    *d is decrypted using our private RSA key
    Is this data for us? If so, decrypt with our AESKM and treat normally.                 //If this socket doesn't have a NextNeighbor, it's for us?
    *If not: 
        RelayParts ( {nextneighborip:{dataparts}} )+= d
        If RelayParts.bytes() >= 256M (should be a user-set variable eventually):      //Let's try it just in RAM first. Writing to disk will be slowwww.
            Don't accept any more incoming data                                                            //Can relayers choke their neighbors?
   *While RelayParts has data:
        Send something from RelayParts to next neighbor outsocket.                        // In order? Random? I think in order for now.

______________________________EOF_______________________________

